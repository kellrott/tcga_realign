#!/usr/bin/python

"""
    cgquery

    Copyright (c) 2011-2012, Annai Systems, Inc.
    All rights reserved.

    Simple client to send a query to the cghub server and parse the 
    resulting XML.    Optionally, the raw XML can be stored to an
    output file for processing by the GeneTorrent client.

    Revision History:
        6-Jan-2012 v1.9:      Version 1 software
       26-Feb-2012 v2.1.0:    Added URL encoding of query strings and 
                              parsing for new cghub error XML.  
                              Cleaned up any backwared-incompatible
                              syntax (through 2.1.1), so we can 
                              exit nicely with older interpreters.
        7-Jun-2012 v2.1.2:    Fixed parsing error when XML tags
                              cross a buffer chunk boundary
       14-Jun-2012 v2.1.3:    Added --count-only flag
       15-Nov-2012 v2.1.4:    Added support for ResultSummary.
                              Removed parsing of specific elements.
       28-Nov-2012 v2.1.5:    Added support for new WSI resources
       12-Dec-2012 v2.1.6:    Added --all-states flag
       13-Dec-2012 v2.1.7:    Changed --output-xml to be quiet
       07-Feb-2013 v2.1.8:    Changed default for -g to be just gtdownload, should be in the path, if not user can submit their own

    When adding an entry to the revision history, be sure to update 
    the CGQUERY_VER value below.

"""

CGQUERY_VER = '2.1.8'

#
# Check the python version for compatability.  Python 3 is not
# backward compatible.   Need to get sys to check the version.
# But, delay the remaining imports because we'd rather spit
# out a version error than an import error if using an old
# interpreter that doesn't have the necessary modules.
#
try:
    import os
    import sys
except:
    # Nothing we can do here
    print "Unable to verify Python version"
    raise

MY_NAME=os.path.basename(sys.argv[0])

if sys.version_info[0] != 2 or sys.version_info[1] < 6:
    sys.stderr.write("%s requires Python version 2.6 or 2.7\n" % MY_NAME)
    sys.exit(1)

#
# Now get the rest of our required modules
#
try:
    import urllib
    import urllib2
    import datetime
    import re
    import optparse 
    import traceback 
    from optparse import OptionParser
    from xml.dom import minidom, Node
    from collections import defaultdict
    from subprocess import call
    from cStringIO import StringIO
except Exception, (err):
    sys.stderr.write("Can't find required Python module (%s)" % (err))
    sys.exit(1)

#
# Check that SSL support is available for the https requests.
#
try:
    import _ssl
except ImportError:
    sys.stderr.write("Python must be compiled with SSL support to use https")
    sys.exit(1)

#
# Constants for contacting the CGHub server.  
#
CGHUB_SVR  = 'https://cghub.ucsc.edu'

CGHUB_VERSION_URI     = '/cghub/interface/version'
CGHUB_QUERY_URI_BASE  = '/cghub/metadata'

#
# In order to process the results in a streaming fashion,
# we have to play some games with the ResultSet element.
# So, setup some common strings here.
#
RESULTSET_TERMTAG  = "/ResultSet"
RESULTSET_TERMELEM = "<%s>"%(RESULTSET_TERMTAG)

CGHUB_VER_MAJOR       = 'major'
CGHUB_VER_MINOR       = 'minor'

#
# Define the query resources based upon the server version
#
CGHUB_VERSION_LEGACY  = 'legacy'
CGHUB_VERSION_STD     = 'standard'

CGHUB_QUERY_ID    = 0       # Core attributes
CGHUB_QUERY_BASE  = 1       # Core attributes
CGHUB_QUERY_FULL  = 2       # Attributes + XML
CGHUB_QUERY_SUB   = 3       # Just XML
CGHUB_QUERY_TYPES = 4

CGHUB_URI = {}
#                                  Ident             Base              Full                  Submission
#                                  -----------       ----------        ----------            ----------
CGHUB_URI[CGHUB_VERSION_LEGACY] = ['analysisObject', 'analysisObject', 'analysisAttributes', None]
CGHUB_URI[CGHUB_VERSION_STD]    = ['analysisId',     'analysisDetail', 'analysisFull',       'analysisSubmission']

#
# Location of the GeneTorrent binary and conf file for interactive mode
#
GT_BIN        = 'gtdownload' 

#
# Column width (up to the :)
#
C_WIDTH =      36   

global Log 
global Stats

#
# Utility lambda functions
#
lowerStr = lambda s: s and s[:1].lower() + s[1:] or ''
upperStr = lambda s: s and s[:1].upper() + s[1:] or ''


#
# Other utility functions
#
def columnize(str, indent, colwidth):
    """ -----------------------------------------------------------------
        Given a string, attempt to break it into a column with the 
        passed indent and column width.  Note that the first line will 
        not be indented.   This is similar to the textwrap module, but 
        customized to work better with our formatting style.
        -----------------------------------------------------------------
    """

    idx = 0
    wsidx = -1
    width = 0

    while True:
        #
        # Are we at the end of the string?
        #
        if idx >= len(str):
            break

        if str[idx] == '\n':
            # 
            # Respect any newlines we find by just forcing a
            # line break
            #
            wsidx = idx
            width = colwidth 
        elif str[idx] == ' ':
            #
            # Keep track of the last space we saw as we may
            # need to use that location as our line break
            #
            wsidx = idx;

        idx = idx+1
        width = width+1

        if (width > colwidth):
            #
            # Okay, we've exceeded the column width.  Go back
            # to the last whitespace and insert a newline
            # followed by the proper indentation, and repeat.
            #
            if wsidx > 0:
                str = str[:wsidx] + "\n" + " " * indent + str[wsidx+1:]
                idx = wsidx + indent + 1
                wsidx = -1
                width = 0
    return str

class StatDict(dict):
    """ =================================================================
        StatDict
        
        Dictionary containing various statistics counters.
        =================================================================
    """
    def __init__(self):
        """ -----------------------------------------------------------------
            Constructor, initializes the known counters
            -----------------------------------------------------------------
        """
        dict.__init__(self, 
                      {"filtered"   : 0,
                       "total"      : 0})

class Logger:
    """ =================================================================
        Logger
        
        Logging object used to output various messages and errors 
        in a consistent format. 
        =================================================================
    """
    #
    # Verbosity levels.
    #
    LOG_VERBOSE_NONE    = 0     # No output except for errors
    LOG_VERBOSE_LOW     = 1     # Minimal output
    LOG_VERBOSE_NORMAL  = 2     # Normal verbose output
    LOG_VERBOSE_DEBUG   = 3     # Normal output plus debug messages
    
    def __init__(self):
        """ -----------------------------------------------------------------
            Constructor
            -----------------------------------------------------------------
        """
        self.vlevel = Logger.LOG_VERBOSE_NORMAL

    def setVLevel(self, vlevel):
        """ -----------------------------------------------------------------
            Set verbose mode
            -----------------------------------------------------------------
        """
        self.vlevel = vlevel

    def VLevel(self):
        """ -----------------------------------------------------------------
            Get verbose mode value
            -----------------------------------------------------------------
        """
        return self.vlevel 

    def status(self, msg):
        """ -----------------------------------------------------------------
            Print a status message to the terminal.  These are intended
            to be temporary messages that get erased, so should not
            have a trailing newline.
            -----------------------------------------------------------------
        """
        if self.vlevel < Logger.LOG_VERBOSE_NORMAL:
            return 0

        if not sys.stdout.isatty():
            return 0
        msglen = len(msg)
        sys.stdout.write(msg)
        sys.stdout.flush()
        return msglen

    def clearStatus(self, msglen):
        """ -----------------------------------------------------------------
            Clear a status message.   msglen is the value returned by
            self.status() above.
            -----------------------------------------------------------------
        """
        if self.vlevel < Logger.LOG_VERBOSE_NORMAL:
            return 

        if sys.stdout.isatty():
            sys.stdout.write('\r' + msglen * ' ' + '\r')
            sys.stdout.flush()

    def __print(self, label, msg, outfd, ofs=0, wrap=True):
        """ -----------------------------------------------------------------
            Internal print routine.  Takes an optional label and then
            the message to output.   By default, the message will be
            wrapped.
            -----------------------------------------------------------------
        """

        if label != None:
            label = label + ": "
        else:
            label = ""

        label = ofs * " " + label

        outfd.write(label)

        if wrap:
            msg = columnize(msg, len(label), 74-len(label))

        outfd.write(msg + "\n")

    def write(self, msg, outfd=sys.stdout):
        """ -----------------------------------------------------------------
            Print a pre-formatted message 
            -----------------------------------------------------------------
        """
        self.__print(None, msg, outfd, ofs=0, wrap=False)

    def debug(self, msg):
        """ -----------------------------------------------------------------
            Print a message in debug mode
            -----------------------------------------------------------------
        """
        if self.vlevel < Logger.LOG_VERBOSE_DEBUG:
            return
        prefix = "{0} Debug".format(datetime.datetime.now())
        self.__print(prefix, msg, sys.stderr, wrap=False )

    def message(self, msg, label=None, ofs=0):
        """ -----------------------------------------------------------------
            Print a message at normal verbosity level
            -----------------------------------------------------------------
        """
        if self.vlevel < Logger.LOG_VERBOSE_LOW:
            return
        self.__print(label, msg, sys.stdout, ofs)

    def messageV(self, msg, label=None, ofs=0):
        """ -----------------------------------------------------------------
            Print a message at high verbosity level
            -----------------------------------------------------------------
        """
        if self.vlevel < Logger.LOG_VERBOSE_NORMAL:
            return
        self.__print(label, msg, sys.stdout, ofs)

    def notice(self, msg, ofs=0):
        """ -----------------------------------------------------------------
            Report a generic notice
            -----------------------------------------------------------------
        """
        self.__print("## NOTICE", msg, sys.stderr, ofs)

    def error(self, type_str, err, ofs=0):
        """ -----------------------------------------------------------------
            Report a generic error 
            -----------------------------------------------------------------
        """
        self.__print("## " + type_str, err, sys.stderr, ofs)

    def execError(self, err, ofs=0):
        """ -----------------------------------------------------------------
            Report a non-fatal execution error 
            -----------------------------------------------------------------
        """
        err_msg = "{0}.  Continuing" . format(err)
        sys.stderr.write("\n")
        self.error("Error", err_msg, ofs)
        sys.stderr.write("\n")

    def fatalError(self):
        """ -----------------------------------------------------------------
            Silently exit with an error status
            -----------------------------------------------------------------
        """
        sys.exit(1)

    def fatalExecError(self, err, doExit=True, ofs=0):
        """ -----------------------------------------------------------------
            Report a fatal execution error to stderr and exit
            -----------------------------------------------------------------
        """
        sys.stderr.write("\n")
        self.error("Error", err, ofs)
        sys.stderr.write("\n")
        if (doExit):
            sys.exit(1)

    def fatalOptError(self, parser, err, ofs=0):
        """ -----------------------------------------------------------------
            Report a fatal option parsing error to stderr and exit
            -----------------------------------------------------------------
        """
        sys.stderr.write("\n")
        self.__print("Error", "%s\n" % (err), sys.stderr, ofs)
        parser.print_help()
        sys.exit(1)

class QueryString:
    """ =================================================================
        QueryString
        
        Object to manage raw and encoded querystrings.
        =================================================================
    """

    def __init__(self, rawqs, sortby):
        """ -----------------------------------------------------------------
            Given a raw (unencoded) string, instantiate a QueryString 
            object that can return either the raw or encoded value.
            Raises an exception if the raw value can not be encoded.
            -----------------------------------------------------------------
        """

        self.encodedqs = ''

        if not rawqs:
            raise ValueError("Non-existent querystring")
        self.rawqs = rawqs

        if sortby != None:
            self.rawqs += "&sort_by={0}".format(sortby)

        qsdict = dict()

        #
        # Split the raw querystring into individual parameters
        #
        for item in self.rawqs.split("&"):
            if not item:
                continue
            #
            # Now extract the actual field/value pair and insert
            # them into the dictionary
            #
            field,value = '',''
            fvp = item.split("=")

            if len(fvp) > 0:
                field=fvp[0]
            if len(fvp) > 1:
                value=fvp[1]
            if len(fvp) > 2:
                raise ValueError("Invalid field=value pair at %s" % item)

            qsdict[field] = value

        #
        # Now do the encoding.   Let any encoding errors get
        # thrown.
        #
        self.encodedqs=urllib.urlencode(qsdict)

    def Raw(self):
        """ -----------------------------------------------------------------
            Return a raw (unencoded) version of the QueryString
            -----------------------------------------------------------------
        """
        return self.rawqs

    def Encoded(self):
        """ -----------------------------------------------------------------
            Return an encoded version of the QueryString
            -----------------------------------------------------------------
        """
        return self.encodedqs

class XMLLogFile:
    """ =================================================================
        XMLLogFile
        
        Manage the output file used to log any XML return data
        =================================================================
    """
    def __init__(self, logfile):
        """ -----------------------------------------------------------------
            Requires a filename.  The file will not be opened until the
            first write.
            -----------------------------------------------------------------
        """
        #
        # Make sure we got a file name
        #
        if logfile == None:
            raise ValueError("XML output file name not set")
        self.xmlfh = None
        self.xmlfilename = logfile

    def Write(self, buffer):
        """ -----------------------------------------------------------------
            Write a buffer to the output file.   Open the file if this
            is the first write.
            -----------------------------------------------------------------
        """
        #
        # Is it open yet?  If not, open it
        #
        if self.xmlfh == None:
            try:
                self.xmlfh = open(self.xmlfilename, 'w')
            except IOError, (err):
                Log.fatalExecError("Failed to open output file (%s)" % err)

        #
        # Now write the data
        #
        try: 
            self.xmlfh.write(buffer)
        except IOError, (err):
            Log.fatalExecError("Failed to write to output file (%s)" % err)

    def Close(self):
        """ -----------------------------------------------------------------
            Close the output file if it's been opened.
            -----------------------------------------------------------------
        """
        if self.xmlfh != None:
            self.xmlfh.close()
            self.xmlfl = None

class ResultStream:
    """ =================================================================
        ResultStream
        
        Streams the XML output in response to a query.  The actual XML 
        is read from the server in large chunks that get parsed and
        handed back to the caller one Result at a time.
        =================================================================
    """


    def __init__(self, xmlstream, size):
        """ -----------------------------------------------------------------
            Initialize the instance variables.  
                buffer : a raw chunk of XML that's been read from the 
                    server.   As requests are made to get additional 
                    Results the beginning of the chunk "slides"
                    forward, and the end grows as needed.   
                chunksize : the size of the individual reads.   
                stream : the file handle for the response 
            -----------------------------------------------------------------
        """
        self.buffer = None
        if size <= 100000:
            self.chunksize = size
        else:
            self.chunksize = 100000
        self.stream = xmlstream

    def Grow(self):
        """ -----------------------------------------------------------------
            Expand the buffer by another chunk.  This might be needed to
            get the next Result, or to find the end of the curren one.
            -----------------------------------------------------------------
        """
        
        #
        # Read another chunk
        #
        b2 = self.stream.read(self.chunksize)
        if not b2: 
            return False

        #
        # And append it to the existing buffer so the caller can just
        # keep scanning through the buffer
        #
        if self.buffer != None:
            self.buffer = self.buffer+b2
        else:
            self.buffer = b2
        return True

    def Close(self):
        """ -----------------------------------------------------------------
            Perform any house keeping
            -----------------------------------------------------------------
        """
        pass
        
    def FindNode(self, node):
        """ -----------------------------------------------------------------
            Locate an XML key (in the form "Key" or "/Key") and return its
            offset (from the beginning of the buffer) and length (up to 
            the closing bracket).
            -----------------------------------------------------------------
        """
        node = "<" + node
        ofs = len(node)

        #
        # Start searching at our current location
        #
        skipped = 0
        start = 0

        while True:
            loc = self.buffer[start:].find(node)

            if loc == -1:
                #
                # Not found in the buffer.   Get some more data
                # and try again.
                #
                if not self.Grow():
                    return (-1,-1)
                continue
            
            end = start + loc + ofs

            if end + 1 > len(self.buffer):
                #
                # The key name spans across a chunk boundary.
                # Get more data and try again.   Add 1 to allow
                # for the closing bracket.
                #
                if not self.Grow():
                    return (-1,-1)
                continue

            if self.buffer[end:][:1] != " " and self.buffer[end:][:1] != '>':
                #
                # Probably found a key that's a superset of the key
                # we want.   Keep looking
                #
                skipped += end
                start = end
                continue

            #
            # Found our node.   Find the closing bracket
            #
            loc2 = self.buffer[start+loc:].find(">")
            if loc2 == -1:
                #
                # The key spans across a chunk boundary.  Get more
                # data and try again.
                #
                if not self.Grow():
                    return (-1,-1)
                continue

            return (skipped+loc,loc2+1)

    def getResultSetXML(self):
        """ -----------------------------------------------------------------
            Returns the XML ResultSet, which is assumed to be the first 
            thing returned by the query. 
            -----------------------------------------------------------------
        """
        #
        # The ResultSet must get loaded before any of the
        # Results
        #
        if self.buffer != None:
            Log.fatalExecError("ResultSet loaded twice")

        #
        # Even if there are no results, we should get
        # something in response to the query.  So, get our
        # first chunk.
        #
        if not self.Grow():
            Log.fatalExecError("Failed to parse ResultSet.  Unexpected response format")

        #
        # Find the beginning of the ResultSet
        #
        rsstart,rslen = self.FindNode('ResultSet')
        if rsstart == -1:
            Log.fatalExecError("ResultSet not found")

        rsendstart,rsendlen = self.FindNode('Result')
        if rsendstart < 0:
            #
            # No <Result> to tell us where the ResultSet ends, so
            # just find the </ResultSet>.   It must be close.
            #
            rsendstart,rsendlen = self.FindNode(RESULTSET_TERMTAG)

        if rsendstart == -1:
            Log.fatalExecError("Unable to find end of ResultSet")

        #
        # Save the ResultSet and terminate it so that we can 
        # load it into a dom
        #
        rsbuffer = self.buffer[rsstart:rsendstart]
        rsbuffer += RESULTSET_TERMELEM

        #
        # Advance the window
        #
        self.buffer = self.buffer[rsendstart:]
        return rsbuffer

    def getNodeBlock(self, tag):
        """ -----------------------------------------------------------------
            Return the next block marked by <tag/> found in the stream.
            -----------------------------------------------------------------
        """
        #
        # Find the beginning
        #
        start,len = self.FindNode(tag)
        if start == -1:
            # No more found
            return None

        #
        # Advance the window to the beginning of the block
        #
        self.buffer = self.buffer[start:]

        #
        # From that point, find the end
        #
        start,len = self.FindNode("/{0}".format(tag))
        if start == -1:
            Log.fatalExecError("Unterminated {0}".format(tag))

        #
        # Save the block of XML, and advance the window
        # past the block, ready for the next search
        #
        block = self.buffer[:start+len]
        self.buffer = self.buffer[start+len:]

        return block

    def getResultXML(self):
        """ -----------------------------------------------------------------
            Return the next Result block found in the stream.
            -----------------------------------------------------------------
        """
        return self.getNodeBlock("Result")

    def getResultSummaryXML(self):
        """ -----------------------------------------------------------------
            Return the ResultSummary block found in the stream.
            -----------------------------------------------------------------
        """
        return self.getNodeBlock("ResultSummary")

class CGObject:
    """ =================================================================
        CGObject
        
        Base class for loading raw cghub XML into a dom
        =================================================================
    """

    def __init__(self, rawxml, col_data=False):
        """ -----------------------------------------------------------------
            Constructor for the CGObject.   Loads the passed XML into
            a DOM.
            -----------------------------------------------------------------
        """
        #
        # Load the XML into a dom
        #
        self.dom = None
        self.dom = minidom.parseString(rawxml)
        self.col_data = col_data

    def __del__(self):
        """ -----------------------------------------------------------------
            Destructor.   Cleans up the DOM before leaving.
            -----------------------------------------------------------------
        """
        if self.dom != None:
            self.dom.unlink()

    def RootNode(self, tag):
        """ -----------------------------------------------------------------
            Locates the root node using the passed tag, and returns
            the associated element.
            -----------------------------------------------------------------
        """

        rootNode=self.dom.firstChild

        if rootNode.tagName != tag:
            raise ValueError("Malformed XML.  {0} root node not found".format(tag))

        return rootNode

    def Element (self, tag, parent=None):
        """ -----------------------------------------------------------------
            Return the value of a single element.
            -----------------------------------------------------------------
        """

        if parent == None:
            parent = self.dom

        elist = parent.getElementsByTagName(tag)

        if elist == None or elist.length == 0:
            raise ValueError("{0} tag not found".format(tag))

        if elist.length != 1:
            raise ValueError("Wrong number of {0} tags found ({1})".format(tag, elist.length))

        return elist[0]

    def ElementValue(self, tag, parent=None):
        """ -----------------------------------------------------------------
            Return the value of a single element.
            -----------------------------------------------------------------
        """

        node = self.Element(tag, parent)

        if node.childNodes.length < 1:
            raise ValueError("Empty {0} value".format(tag))

        return node.childNodes[0].nodeValue

    def GetAttrs_default(self, tag, node):
        """ -----------------------------------------------------------------
            Default function to format the attributes for the
            passed XML node.  By default, we don't assume any
            attributes.
            -----------------------------------------------------------------
        """
        return ""

    def ElementAttrs(self, tag, node):
        """ -----------------------------------------------------------------
            Parse attributes for the current node.  This is done
            by looking for a function named GetAttrs_<Tag>.  If
            not found, then GetAttrs_default() is called.  See
            GetAttrs_result() for an example of an element-specific 
            function.
            -----------------------------------------------------------------
        """
        return getattr(self, 'GetAttrs_'+tag,self.GetAttrs_default)(tag, node)

    def Action_default(self, tag, node):
        """ -----------------------------------------------------------------
            Default function to perform any element-specific actions
            for the passed XML node.  By default, we assume no action.
            attributes.
            -----------------------------------------------------------------
        """
        pass

    def ElementAction(self, tag, node):
        """ -----------------------------------------------------------------
            Do any element-specific processing for the current tag by 
            looking for a function named Action_<Tag>.  If not found, 
            then Action_default() is called.  See Action_analysis_data_uri() 
            for an example of an element-specific function.
            -----------------------------------------------------------------
        """
        return getattr(self, 'Action_'+tag,self.Action_default)(tag, node)

    def Print_default(self, head_str, subnode, outfd):
        """ -----------------------------------------------------------------
            Default function to perform any element-specific actions
            for the passed XML node.  
            -----------------------------------------------------------------
        """
        if subnode.childNodes.length == 0:
            # Leaf.  We already printed the data when processing the parent.
            return False
        elif subnode.childNodes.length > 1:
            # Intermediate node.  Print the tag and traverse the children.
            outfd.write(head_str + "\n")
            return True
        else:
            # Last node before the leaf.  Print the tag and the contents
            # of the child.
            dataVal = subnode.childNodes[0].nodeValue
            if self.col_data:
                dataVal = columnize(dataVal, C_WIDTH+3, 76-(C_WIDTH+3))
            outfd.write("{0:{1}} : {2}\n" . format (head_str, C_WIDTH, dataVal))
            return False

    def ElementPrint(self, tag, head_str, subnode, outfd):
        """ -----------------------------------------------------------------
            Do any element-specific printing for the current tag by 
            looking for a function named Print <Tag>.  If not found, 
            then Print_default() is called.  See Action_analysis_data_uri() 
            for an example of an element-specific function.   Note that
            it is assumed that the caller has already performed any
            necessary verbosity checks.
            -----------------------------------------------------------------
        """
        return getattr(self, 'Print_'+tag,self.Print_default)(head_str, subnode, outfd)

    def TraverseElement(self, elem, title, indent, outfd):
        """ -----------------------------------------------------------------
            Recursively traverse the passed element, printing the tags
            for each node as well as the value of any leaf text nodes that 
            we find.
            -----------------------------------------------------------------
        """

        self.ElementAction(elem.nodeName, elem)

        attr_str = self.ElementAttrs(elem.nodeName, elem)

        width  = C_WIDTH - indent

        if title == None:
            title = elem.nodeName

        if attr_str != None and len(attr_str) > 0:
            title  = title + " " + attr_str

        head_str = " " * indent + title

        numChildren = len(elem.childNodes)

        traverse = self.ElementPrint(elem.nodeName, head_str, elem, outfd)

        if traverse:
            for child in elem.childNodes:
                self.TraverseElement(child, child.nodeName, indent + 4, outfd)


class CGError(CGObject):
    """ =================================================================
        CGError
        
        Manage the CGHUB_error object downloaded from cghub HTTP
        error messages
        =================================================================
    """
    def __init__(self, rawxml):
        CGObject.__init__(self, rawxml, col_data=True)

    def doTraverse(self, outfd=sys.stderr):
        """ -----------------------------------------------------------------
            Traverse the CGHUB_error, printing the child elements to stdout.
            -----------------------------------------------------------------
        """
        self.TraverseElement(self.RootNode('CGHUB_error'), "Error Details", 4, outfd)
        outfd.write("\n")

    def PrintDetails(self):
        """ -----------------------------------------------------------------
            Parse the XML error information.  We only know how to parse
            the CGHUB_error element.  Anything else will generate an
            exception.
            -----------------------------------------------------------------
        """
        self.doTraverse()

class GNOSResult(CGObject):
    """ =================================================================
        GNOSResult
        
        Manage the GNOS_result object downloaded from cghub 
        =================================================================
    """
    def __init__(self, rawxml):
        CGObject.__init__(self, rawxml, col_data=True)

        try:
            #
            # Make sure we got the right structure, and if so,
            # extract the version tag value.
            #
            root = self.RootNode('GNOS_result')

            wsi = self.Element('WebServices')

            self.version = self.ElementValue('version', wsi)

        except Exception, err:
            Log.fatalExecError("Failed to parse server version information: %s" % (err))


class ResultSet(CGObject):
    """ =================================================================
        ResultSet
        
        ResultSet object downloaded from cghub.  
        =================================================================
    """

    def __init__(self, rawxml):
        
        try:
            CGObject.__init__(self, rawxml)
        except Exception, err:
            Log.fatalExecError("Error parsing XML (%s)" % err)

    def doTraverse(self, outfd=sys.stdout):
        """ -----------------------------------------------------------------
            Traverse this ResultSet, printing the contents to the passed
            file.  
            -----------------------------------------------------------------
        """
        #
        # Locate the Hits tag.  Should be one and only one.
        #
        try:
            hitCount = self.ElementValue('Hits')
        except Exception, err:
            Log.fatalExecError("Failed to determine hit count: {0}".format(err))

        if Log.VLevel() < Logger.LOG_VERBOSE_LOW:
            return

        ofs=4
        width=C_WIDTH-ofs
        outfd.write(ofs * " " + "{0:{1}} : {2}\n" . format ("Matching Objects", width, hitCount))
        outfd.write(76 * "=" + "\n")

class Result(CGObject):
    """ =================================================================
        Result
        
        Result object downloaded from cghub.   This does the work of 
        parsing and printing the result information.
        =================================================================
    """
    
    def __init__(self, rawxml):
        """ -----------------------------------------------------------------
            Initialize the instance variables
            -----------------------------------------------------------------
        """
        self.uriList = []
        self.fileIdx = 0

        try:
            CGObject.__init__(self, rawxml)
        except Exception, err:
            Log.fatalExecError("Error parsing XML (%s)" % err)

    def Action_analysis_data_uri(self, tag, node):
        """ -----------------------------------------------------------------
            Perform analysis_data_uri specific actions.  Specifically, save
            off the analysis URI value for future processing by the
            GeneTorrent client.
            -----------------------------------------------------------------
        """
        self.uriList.append(node.childNodes[0].nodeValue)

    def Print_files(self, head_str, subnode, outfd):
        """ -----------------------------------------------------------------
            Print the 'files' element.  This has special handling so that
            we can keep track of when we've hit a new list of files and
            reset the index.
            -----------------------------------------------------------------
        """
        self.fileIdx = 0   # Reset
        return self.Print_default(head_str, subnode, outfd)

    def Print_file(self, head_str, subnode, outfd):
        """ -----------------------------------------------------------------
            Print the 'file' element.   This has special handling so that
            we can add an index to each file in the list.
            -----------------------------------------------------------------
        """
        self.fileIdx += 1
        head_str = "{0} {1}" . format (head_str, self.fileIdx)
        return self.Print_default(head_str, subnode, outfd)

    def Print_xml(self, head_str, subnode, outfd):
        """ -----------------------------------------------------------------
            For elements containing XML documents, just print the length of 
            the XML, not all the data.
            -----------------------------------------------------------------
        """
        if subnode.childNodes.length == 0:
            # No XML was present
            dataVal = "" 
        else:
            dataVal = "{0} bytes of XML".format(len(subnode.toxml()))

        outfd.write("{0:{1}} : {2}\n" . format (head_str, C_WIDTH, dataVal))
        return False

    def Print_analysis_xml(self, head_str, subnode, outfd):
        return self.Print_xml(head_str, subnode, outfd)

    def Print_run_xml(self, head_str, subnode, outfd):
        return self.Print_xml(head_str, subnode, outfd)

    def Print_experiment_xml(self, head_str, subnode, outfd):
        return self.Print_xml(head_str, subnode, outfd)

    def Action_analysis_id(self, tag, node):
        """ -----------------------------------------------------------------
            Perform analysis_id specific actions.  Specifically, save the
            uuid so we can report it later
            -----------------------------------------------------------------
        """
        self.uuid = node.childNodes[0].nodeValue

    def Action_state(self, tag, node):
        """ -----------------------------------------------------------------
            Perform state specific actions.  Specifically, save the state
            so that we can filter out certain results.
            -----------------------------------------------------------------
        """
        self.state = node.childNodes[0].nodeValue.lower()

    def doTraverse(self, id, outfd):
        """ -----------------------------------------------------------------
            Traverse all of the subnodes in this Result, printing the
            contents to stdout.
            -----------------------------------------------------------------
        """
        #
        # Note that unlike some of the other CGObjects, we don't
        # check the verbosity here and bail out before traversal
        # because we may need to collect statistics from the
        # Result during traversal.  So the decision on whether
        # to actually generate output is made by the caller.
        #
        title="Analysis {0}".format(id)
        self.TraverseElement(self.RootNode('Result'), title, 4, outfd)

    def isDownloadable(self):
        """ -----------------------------------------------------------------
            Return True if the result is in a downloadable (live) state
            -----------------------------------------------------------------
        """
        return self.state == "live"

    def getAnalysisId(self):
        """ -----------------------------------------------------------------
            Return the uuid for this result
            -----------------------------------------------------------------
        """
        return self.uuid

    def getUriList(self):
        """ -----------------------------------------------------------------
            Return the list of URIs collected as we traversed this Result.
            -----------------------------------------------------------------
        """
        return self.uriList

class ResultSummary(CGObject):
    """ =================================================================
        ResultSummary
        
        ResultSummary object downloaded from cghub.  
        =================================================================
    """

    def __init__(self, rawxml):
        
        try:
            CGObject.__init__(self, rawxml)
        except Exception, err:
            Log.fatalExecError("Error parsing XML (%s)" % err)

    def GetAttrs_downloadable_file_size(self, tag, node):
        """ -----------------------------------------------------------------
            Parse and format the attributes for the total_filesize
            element.
            -----------------------------------------------------------------
        """
        units = node.getAttribute('units')
        if len(units) > 0:
            return "(%s)"%(units)
        return None

    def doTraverse(self, outfd=sys.stdout):
        """ -----------------------------------------------------------------
            Traverse this ResultSummary, printing the contents to stdout.
            -----------------------------------------------------------------
        """
        if Log.VLevel() < Logger.LOG_VERBOSE_LOW:
            return

        outfd.write("\n")
        self.TraverseElement(self.RootNode('ResultSummary'), "Summary of Matching Objects", 4, outfd)


class CGHubQuery:
    """ =================================================================
        CGHubQuery
        
        Class to perform a single CGHub query and parse the XML that's 
        returned.

        Basic Usage:
            CGHubQuery()      - Instantiate the query object
            DumpHeader()      - Dump out the execution parameters
            GET()             - Perform the GET operation
            ParseResultSet()  - Parse the ResultSet container
            ParseNextResult() - The next Result container in the stream
            DumpFooter()      - Dump out a summary of the results
        =================================================================
    """
    def __init__(self, cgsvr, qtype, qarg, inxml, outxml, dloadonly):
        """ -----------------------------------------------------------------
            Initialize the instance variables
            -----------------------------------------------------------------
        """
        self.infh = None
        self.stream = None
        self.uriList = []
        self.server = cgsvr
        self.inxml = inxml
        self.outxml = outxml
        self.logfile = None

        self.dloadonly = dloadonly          # Display only live objects
        self.dispcount = 1                  # Index of each of the displayed objects

        if self.outxml != None:
            self.logfile = XMLLogFile(self.outxml)
        self.rslogged = False

        self.uri = None
        self.server_verstr = "Unknown"
        self.server_verclass = CGHUB_VERSION_LEGACY

        #
        # If we're getting our input from a file, then
        # there's no way to get server version info
        #
        if self.inxml == None:
            verstr = self.GetVersion()
            if verstr != None:
                self.server_verstr = verstr
            verdata = self.ParseVersion(verstr)
            #
            # We consider any server that doesn't implement the version
            # API to be "legacy"
            #
            if verdata[CGHUB_VER_MAJOR] >= 0:
                self.server_verclass = CGHUB_VERSION_STD
            self.uri = self.GetURI(qtype, qarg, self.server_verclass)

    def DumpHeader(self, qs):
        """ -----------------------------------------------------------------
            Dump out a header that describes this query execution
            -----------------------------------------------------------------
        """

        if Log.VLevel() < Logger.LOG_VERBOSE_LOW:
            return

        attrs = [ ("Script Version",        CGQUERY_VER) ]

        if self.inxml == None:
            attrs += \
                [ ("CGHub Server",                   self.server),
                  ("WebServices Interface Version",  self.server_verstr),
                  ("REST Resource",                  self.uri),
                  ("QueryString",                    qs.Raw()) ]
        else:
            attrs += \
                [ ("Input File",                     self.inxml) ]

        attrs += \
                [ ("Output File",                    self.outxml) ]

        Log.write("")
        Log.write(76 * "=")
        ofs=4
        width=C_WIDTH-ofs
        for attr in attrs:
            Log.write(ofs * " " + "{0:{1}} : {2}" . format (attr[0], width, attr[1]))
        Log.write(76 * "-")

    def DumpFooter(self):
        """ -----------------------------------------------------------------
            Dump out a footer that summarizes the query execution
            -----------------------------------------------------------------
        """

        Log.write("")

        #
        # If we're showing all states or if there were no matching objects, 
        # then no filtering took place.
        #
        if not self.dloadonly or Stats["total"] == 0:
            return

        #
        # If we're in a quiet mode and we're not writing to the XML file,
        # then the user is not seeing any analysis objects at all.   So,
        # there's no reason to issue warnings about filtered objects.
        #
        if Log.VLevel() < Logger.LOG_VERBOSE_NORMAL and self.logfile == None:
            return

        #
        # We are in download-only mode.   Let the user know how many objects 
        # were filtered from the display and/or the log file.
        #
        logmsg = loglabel = None
        ofs=4
        filterCount = Stats["filtered"]

        if filterCount > 0:
            loglabel = "## NOTICE"
            if filterCount == Stats["total"]:
                # Everything got filtered!
                logmsg = "None of the matching objects are in a downloadable state, and therefore no results were"
            elif filterCount == 1:
                logmsg = "%d matching object is not in a downloadable state, and was therefore not"%(filterCount)
            else:
                logmsg = "%d matching objects are not in a downloadable state, and were therefore not"%(filterCount)

            if Log.VLevel() >= Logger.LOG_VERBOSE_NORMAL:
                logmsg += " displayed"
            if Log.VLevel() >= Logger.LOG_VERBOSE_NORMAL and self.logfile != None:
                logmsg += " or"
            if self.logfile != None:
                logmsg += " written to the output file"
            logmsg += ".  To see all matching objects regardless of state, use the --all-states option."

        elif Stats["total"] != 0:
            logmsg = "All matching objects are in a downloadable state."

        #
        # If we got anything to log, print a separator and then the message
        #
        if logmsg != None: 
            Log.message(76 * "-")
            Log.message(logmsg, label=loglabel, ofs=ofs)
            Log.message(76 * "-")

    def OpenInFile(self, inxml):
        """ -----------------------------------------------------------------
            Open an input file instead of executing a query.  For testing
            purposes only.
            -----------------------------------------------------------------
        """
        try:
            infh = open(inxml, "r")
        except IOError, (err):
            Log.fatalExecError("Can't open input file {0} ({1})".format(inxml, err)) 

        return infh

    def ParseXMLError(self, httperrfmt, httperr):
        """ -----------------------------------------------------------------
            Parse the XML that's returned as part of an HTTP Error 
            -----------------------------------------------------------------
        """
        
        #
        # Dump the HTTP error but don't exit just yet
        #
        Log.fatalExecError(httperrfmt % (httperr), False)

        rawxml = httperr.read()

        #
        # Log it (if needed)
        #
        if self.logfile != None:
            self.logfile.Write(rawxml)

        try:
            #
            # Parse the XML
            #
            errorobj = CGError(rawxml)

            #
            # Dump the contents
            #
            errorobj.PrintDetails()

        except Exception, err:
            Log.error("Error", "Unable to parse error details from XML response", 8)

        Log.fatalError()

    def GetURI(self, query_type, query_arg, server_verclass):
        """ -----------------------------------------------------------------
            Return the query URI based upon the server version and whether
            the user used the -a flag.
            -----------------------------------------------------------------
        """
        query_string = None
        
        for query_idx in reversed(range(CGHUB_QUERY_ID,query_type+1)):
            query_string = CGHUB_URI[server_verclass][query_idx] 
            if query_string != None:
                break

        if query_string == None:
            Log.fatalExecError("Unable to determine {0} URI for query type {1}".format(server_verclass, query_type))

        if query_idx != query_type:
            Log.notice("Server version does not support the selected query type.  Falling back to {0}".format(query_string))
            query_arg = None

        uri = CGHUB_QUERY_URI_BASE + '/' + query_string

        if query_arg != None:
            uri = uri + '/' + query_arg

        return uri

    def ParseVersion(self, version_string):
        """ -----------------------------------------------------------------
            Given a version string returned by the server, parse it into
            a major/minor.   Note that older servers may not implement the
            anyout = True
            API. So, we treat an NULL string as the oldest possible 
        if anyout:
            version. 
            -----------------------------------------------------------------
        """

        version = { CGHUB_VER_MAJOR : -1, CGHUB_VER_MINOR : -1 }

        try:
            if version_string == None:
                # Version WSI not implemented
                return version

            verparts = version_string.split(".")

            if len(verparts) < 1:
                raise ValueError("Invalid version string '%s'" % version_string)

            version[CGHUB_VER_MAJOR] = int(verparts[0])
            if len(verparts) > 1:
                version[CGHUB_VER_MINOR] = int(verparts[1])

            return version

        except Exception, err:
                Log.fatalExecError("Failed to parse server version information: %s" % (err))


    def GetVersion(self):
        """ -----------------------------------------------------------------
            Query the server for the interface version, and parse into
            a major/minor.   Note that older servers may not implement the
            API.   In that case, default to the oldest possible version. 
            -----------------------------------------------------------------
        """

        if self.inxml != None:
            # We're using a local file instead of a query
            return None
        else:
            url = self.server + CGHUB_VERSION_URI

            try:

                fh = urllib2.urlopen(url)

            except (urllib2.HTTPError), err:        

                # Assume we are talking to an older server with
                # no 'version' interface
                return None

            except (ValueError, urllib2.URLError), err:        

                Log.fatalExecError("Failed to query server version (%s)" % err)

        rawxml = fh.read()
        fh.close()
        gnos_result = GNOSResult(rawxml)
        return gnos_result.version

    def GET(self, qs):
        """ -----------------------------------------------------------------
            Perform the HTTP GET, passing the encoded query string.
            Enough of the resulting XML is read and parsed to get the number
            of results, which is returned for further processing.
            -----------------------------------------------------------------
        """

        errfmt="Query failed (%s)"

        if self.inxml != None:
            # We're using a local file instead of a query
            self.infh = self.OpenInFile(self.inxml)
        else:
            Log.debug("Sending querystring '%s'..." % qs.Encoded())
            url = self.server + self.uri + "?" + qs.Encoded()

            mlen = Log.status("Query in progress...")

            try:
                self.infh = urllib2.urlopen(url)

            except (urllib2.HTTPError), err:        

                Log.clearStatus(mlen)

                if err.info()['Content-Type'] == "text/xml":
                    self.ParseXMLError(errfmt, err)
                else:
                    Log.fatalExecError(errfmt % (err))

            except (ValueError, urllib2.URLError), err:        

                Log.clearStatus(mlen)
                Log.fatalExecError(errfmt % err)

            Log.clearStatus(mlen)
            Log.debug("Query complete.")

        self.stream = ResultStream(self.infh, 128 * 1024)


    def ParseResultSet(self):
        """ -----------------------------------------------------------------
            Parse the initial "ResultSet" XML to get the number of expected
            result objects.
            -----------------------------------------------------------------
        """
        if self.stream == None:
            Log.fatalExecError("Attempt to parse results before query")

        rawxml = self.stream.getResultSetXML()

        #
        # Log the unterminated buffer, so we have properly formed
        # XML in the log
        #
        if self.logfile != None:
            termstart = rawxml.find(RESULTSET_TERMELEM)
            self.logfile.Write(rawxml[:termstart])
            self.rslogged = True

        resultset = ResultSet(rawxml)

        resultset.doTraverse()

    def ParseNextResult(self):
        """ -----------------------------------------------------------------
            Parse the next "Result" XML read from the stream into a dom,
            and then print the contents.
            -----------------------------------------------------------------
        """
        global Stats

        if self.stream == None:
            Log.fatalExecError("Attempt to parse results before query")

        Log.debug("Reading next object from result stream")
        
        #
        # Get the next result text from the stream
        #
        rawxml = self.stream.getResultXML()
        if rawxml == None:
            # No more
            return False

        Log.debug("Got {0} bytes of XML".format(len(rawxml)))

        # 
        # Instantiate the appropriate type of Result object dom
        #
        result = Result(rawxml)

        #
        # Traverse the object, printing the contents to a local buffer
        # so that we can do any necessary filtering before display
        #
        outfd = StringIO()
        result.doTraverse(self.dispcount, outfd)

        Stats["total"] += 1

        ofs=4
        if not self.dloadonly or result.isDownloadable(): 
            if Log.VLevel() >= Logger.LOG_VERBOSE_NORMAL:
                sys.stdout.write("\n" + outfd.getvalue())
            self.dispcount += 1
            #
            # Save any URIs found in this result in case we're interactive
            #
            self.uriList.extend(result.getUriList())

            #
            # We only log unfiltered results
            #
            if self.logfile != None:
                self.logfile.Write(rawxml)
        elif self.dloadonly:
            Stats["filtered"] += 1
            Log.debug("Filtered non-live result for {0}".format(result.getAnalysisId()))

        outfd.close()

        return True

    def ParseResultSummary(self):
        """ -----------------------------------------------------------------
            Parse the "ResultSummary" XML read from the stream into a dom,
            and then print the contents.
            -----------------------------------------------------------------
        """

        if self.stream == None:
            Log.fatalExecError("Attempt to parse results before query")
        
        #
        # Get the result summary text from the stream
        #
        rawxml = self.stream.getResultSummaryXML()
        if rawxml == None:
            #
            # Not found.  This is considered acceptible because we 
            # may be talking to a server that doesn't have it yet.
            #
            return 

        # 
        # Instantiate the ResultSummary object dom
        #
        resultsum = ResultSummary(rawxml)

        #
        # Traverse the object, printing the contents
        #
        resultsum.doTraverse()

        #
        # We only log unfiltered results
        #
        if self.logfile != None:
            self.logfile.Write(rawxml)

    def getURIList(self):
        """ -----------------------------------------------------------------
            Return the total list of all URIs found, across all Results
            -----------------------------------------------------------------
        """
        return self.uriList

    def Close(self):
        """ -----------------------------------------------------------------
            Clean up this query operation.  Note that this may be called
            following an exception, so don't make any assumptions about
            the state of the object.
            -----------------------------------------------------------------
        """
        try: 
            if self.infh:
                self.infh.close()
                self.infh = None

            if self.stream:
                self.stream.Close()
                self.stream = None

            if self.logfile:
                #
                # Log the ResultSet terminator before we go
                #
                if self.rslogged:
                    self.logfile.Write(RESULTSET_TERMELEM)
                self.logfile.Close()
                self.logfile = None

        except IOError, (err):
            Log.fatalExecError("Failed to close file")



def GTDownload(uri, prog, credFile, confdir):
    """ -----------------------------------------------------------------
        Perform a single GeneTorrent download.   Returns True on 
        success, False on (non-fatal) failure.
        -----------------------------------------------------------------
    """
    print "\nProcessing URI " + uri

    cmdline = [prog, 
               "-v",
               "-c", credFile,
               "-d", uri]

    if confdir != None:
        cmdline.extend(["--confDir", confdir])

    print "\nExecuting command '{0}'\n".format(" ".join(cmdline))

    try:
        ec = call(cmdline)
    except OSError, (err):
        Log.fatalExecError("Failed to execute {0} ({1})" . format(prog, err))
    except KeyboardInterrupt:
        # ^C.  Simulate a sigint but continue to the next download
        ec = -2
        

    #
    # Check the exit code/signal status
    #
    rc = False
    if ec < 0:
        Log.execError (prog + " was killed by signal {0}" . format(-ec))
    elif ec > 0:
        Log.execError (prog + " failed with return code {0}" . format(ec))
    else:
        rc = True
        print prog + " returned success."

    return rc

def InteractiveGT(uriList, gtbin, credFile, confdir):
    """ -----------------------------------------------------------------
        Interactively download specific URIs found in the XML using 
        GeneTorrent
        -----------------------------------------------------------------
    """

    if uriList == None or len(uriList) == 0:
        print "No analysis URI values found in downloaded XML"
        return

    fmt_str = 4 * " " + "[{0:2}] : {1}" 
    while True:
        print "Enter the index of a URI to download (0 for all), a range\nof indeces separated by dash, or 'q' to quit"
        print fmt_str . format(0,"All URIs")
        for idx, uri in enumerate(uriList):
            print fmt_str . format(idx+1, uri)
        print

        #
        # Read the index (offset by 1) from the cmd line
        #
        response = raw_input("Index (0=all, q=quit)> ")

        #
        # Consider anything starting with 'q' as 'quit'
        #
        if response[:1] == 'q':
            print ""
            break

        try:
            if re.match('(\d+)-(\d+)$',response):
                # Got a range
                idx_range = [int(i) for i in re.findall(r'(\d+)', response)]
                assert len(idx_range) == 2
                start_idx = idx_range[0]
                end_idx = idx_range[1]

                if start_idx > end_idx:
                    print "Invalid range.  Starting index is greater than ending index.\n"
                    continue

                if start_idx == 0:
                    print "Invalid range.  0 is reserved for all.\n"
                    continue

                assert end_idx <= len(uriList)
                start_idx = start_idx - 1
            else:
                if re.match('(\d+)$',response):
                    # Got a single index
                    idx = int(response)
                    assert idx >= 0 and idx <= len(uriList)

                    if idx > 0:
                        end_idx = idx
                    else:
                        end_idx = len(uriList)

                    if idx > 0:
                        start_idx = idx-1
                    else:
                        start_idx = idx
                else:
                    # Got invalid input
                    print "Invalid input format.\n"
                    assert False
        except (ValueError, AssertionError):
            print "Index must be a numeric value between 0 and {0} or a range\nof values separated by dash.\n" . format(len(uriList))
            continue
        
        success = 0

        for idx in range(start_idx, end_idx):
            #
            # Execute the GeneTorrent command
            #
            if GTDownload(uriList[idx], gtbin, credFile, confdir) == True: success += 1

        print
        print 76 * "-"
        print "{0} of {1} downloads completed successfully".format(success, end_idx-start_idx)
        print 76 * "-"
        print



def main():
    """ -----------------------------------------------------------------
        main
    
        Parses the command line arguments to get the query string.  
        Instantiates a CGHubQuery object, performs a GET with the
        query string, and then parses the resulting XML.
        -----------------------------------------------------------------
    """
    cq = None

    #
    # Parse the command line arguments
    #
    epilog = '<querystring> should be the fully quoted query string, without the question mark separator, e.g. "disease_abbr=COAD".'

    parser = OptionParser(usage='%prog [options] <querystring>', version='%prog version '+CGQUERY_VER+' (c) 2012 Annai Systems, Inc. All rights reserved.', epilog=epilog)
    
    parser.add_option("", "--input-xml",
                      action="store", type="string", dest="inputxml",
                      help=optparse.SUPPRESS_HELP)

    parser.add_option("", "--debug",
                      action="store_true", dest="debug", default=False,
                      help=optparse.SUPPRESS_HELP)

    parser.add_option("-o", "--output-xml",
                      action="store", type="string", dest="outputxml",
                      help="save output to a file as raw xml instead of displaying formatted results")

    parser.add_option("-s", "--server",
                      action="store", type="string", dest="server", default=CGHUB_SVR,
                      help="CGHub server location, including protocol and port, e.g. https://cghub.ucsc.edu")

    parser.add_option("-S", "--sort",
                      action="store", type="string", dest="sortby", 
                      help="attribute by which results should be sorted.  May be followed by an :asc or :desc to indicate ascending or descending order.")

    parser.add_option("-g", "--gt-binary",
                      action="store", type="string", dest="gtbin", default=GT_BIN,
                      help="the GeneTorrent binary used in interactive mode.  Use a fully qualified path if the binary is not in your PATH. e.g. /usr/bin/gtdownload")

    parser.add_option("-I", "--ident",
                      action="store_true", dest="ident", default=False,
                      help="query only the minimal set of fields to identify the analysis object.")

    parser.add_option("-b", "--submission",
                      action="store", type="string", dest="submission",
                      help="query only the named submission metadata, or 'all' for all metadata.")

    parser.add_option("-f", "--conf-dir",
                      action="store", type="string", dest="confdir", default=None,
                      help="path to the GeneTorrent configuration file")

    parser.add_option("-a", "--attributes",
                      action="store_true", dest="attributes", default=False,
                      help="query the full set of analysis attributes, including submission metadata")

    parser.add_option("-i", "--interactive",
                      action="store_true", dest="interactive", default=False,
                      help="enable interactive mode")

    parser.add_option("-n", "--count-only",
                      action="store_true", dest="countonly", default=False,
                      help="report only a count of matching results.  Not available in interactive mode.")

    parser.add_option("-A", "--all-states",
                      action="store_false", dest="dloadonly", default=True,
                      help="output non-downloadable objects.   By default only downloadable objects are displayed or written to the XML output file.")

    parser.add_option("-c", "--credential",
                      action="store", type="string", dest="credential",
                      help="file containing the GeneTorrent credential.  Only required for interactive mode.")

    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="enable verbose output, even when writing XML output to a file.")

    (options, args) = parser.parse_args()

    if len(args) == 0:
        Log.fatalOptError (parser, "Querystring must be provided")

    if len(args) > 1:
        Log.fatalOptError (parser, "Only one querystring may be provided")

    if options.interactive:
        if options.credential == None:
            Log.fatalOptError (parser, "Credential is required in interactive mode")
        if options.countonly:
            Log.fatalOptError (parser, "Count-only option is only allowed in non-interactive mode")
    else:
        if options.credential != None:
            Log.fatalOptError (parser, "Credential is only used in interactive mode")

    #
    # Determine the requested query type.  The --submission option takes
    # an argument that is the name of the desired metadata, or 'all' for
    # all metadata.
    #
    mc = int(options.attributes) + int(options.ident) + int(options.submission != None)
    if mc > 1:
        Log.fatalOptError (parser, "Only one of --attributes, --ident or --submission may be given")

    qtype = CGHUB_QUERY_BASE
    qarg = None

    if options.ident:
        qtype = CGHUB_QUERY_ID
    if options.attributes:
        qtype = CGHUB_QUERY_FULL
    elif options.submission != None:
        qtype = CGHUB_QUERY_SUB
        if options.submission != 'all':
            qarg = options.submission

    sortby = options.sortby

    #
    # By default, if writing output to an XML file, then we operate 
    # in quiet mode.  But, this can be overridded by --verbose or 
    # --interactive, # which isn't very useful without any results 
    # shown.
    #
    vlevel = Logger.LOG_VERBOSE_NORMAL
    if options.outputxml and not options.verbose and not options.interactive:
        vlevel = Logger.LOG_VERBOSE_LOW
    if options.debug:
        vlevel = Logger.LOG_VERBOSE_DEBUG
    Log.setVLevel(vlevel)

    try:
        #
        # Instantiate the query object, execute the query, and parse the XML
        #
        cq = CGHubQuery(options.server, qtype, qarg, options.inputxml, options.outputxml, options.dloadonly)

        #
        # Instantiate the querystring object.  This will raise an exception if
        # the string is invalid.
        #
        if sortby != None and cq.server_verclass == CGHUB_VERSION_LEGACY:
            Log.notice("Server version does not support sort.  Ignoring --sort option")
            sortby = None
            
        try:
            qs = QueryString(args[0], sortby)
        except (UnicodeEncodeError, ValueError), err:
            Log.fatalOptError (parser, "Invalid querystring: %s" % err)

        #
        # Dump the header before starting the query, in case the query 
        # takes a while, and turns out to be the wrong one.
        #
        cq.DumpHeader(qs)

        cq.GET(qs)

        cq.ParseResultSet()

        #
        # If user just wants a count, that is part of the ResultSet, so
        # we're done.  Otherwise, traverse the individual Result elements.
        #
        if not options.countonly:
            #
            # We process one Result at a time to allow us to scale to large numbers
            # of results
            #
            while cq.ParseNextResult():
                pass
            cq.ParseResultSummary()

            cq.DumpFooter()

        if options.interactive:
            InteractiveGT(cq.getURIList(), options.gtbin, options.credential, options.confdir)

    except:
        #
        # Just clean up and pass the exception along.   We don't use
        # finally for this purpose as it's not syntactally backward
        # compatible.
        #
        if cq:
            cq.Close()
        raise

    cq.Close()

if __name__ == "__main__":
    Log = Logger()
    Stats = StatDict()
    try:
        main()

    except SystemExit, err:
        #
        # Exit from within the script
        #
        sys.exit(err)

    except (KeyboardInterrupt, EOFError):
        #
        # Generic ^C/^D Handler so we don't spit out a python stack.
        #
        sys.stderr.write("\nKilled.\n")
        sys.exit(1)

    except IOError, err:
        #
        # Some kind of IO Error.  If it's a broken pipe (32), just 
        # exit silently -- user probably quit out of more or some 
        # other output processor.   Otherwise, try to spit out an 
        # error.
        #
        if err.errno == 32:
            sys.exit(0)
        sys.stderr.write("\nIOError (%s)\n" % err)
        sys.exit(1)

    except:
        #
        # All other uncaught errors.   
        #
        sys.stderr.write("\nInternal Error:\n\n")
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)

